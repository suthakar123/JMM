% TABLE OF CONTENTS:
%
%  #1 - LearningGUI:
%           Necessary initialiazation code for the GUI
%  #2 - LearningGUI_OpeningFcn:
%           Executes just before LearningGUI is made visible
%  #3 - LearningGUI_OutputFcn:
%           Outputs from this function are returned to the command line
%  #4 - LoadDataButton_Callback:
%           Loads data into the handles.database structure. Starts by 
%           prompting the user for a directory in which to find data files. 
%           Then it iterates through each of the data files and records the 
%           data into handles.database
%  #5 - SubjectPopUp_Callback:
%           Called when the user makes a selection through the Subjects 
%           popup. Makes sure that the Trial, Activity and Channel popups 
%           are reset when a new subject is picked
%  #6 - SubjectPopUp_CreateFcn:
%           Adjusts the Subjects popup colors for Windows machines
%  #7 - TrialPopUp_Callback:
%           Called when the user makes a selection through the Trial popup.
%           Makes sure that the Activity and Channel popups are reset when 
%           a new trial is picked
%  #8 - TrialPopUp_CreateFcn:
%           Adjusts the Trial popup colors for Windows machines
%  #9 - ActivityPopUp_Callback:
%           Called when the user makes a selection through the Activity 
%           popup. Makes sure that the Channel popup is reset when a new
%           activity is picked
% #10 - ActivityPopUp_CreateFcn:
%           Adjusts the Activity popup colors for Windows machines
% #11 - GraphActivity:
%           This function will look at the state of all the user selections 
%           and will graph the selected subject/trial/activity/channel
%           combination
% #12 - MakeTimeVector:
%           This function will take the number of timesteps in a given data 
%           vector and create a time vector for graphing the data vector 
%           with a proper time scale
% #13 - ClassifyButton_Callback:
%           Creates a classification tree from the loaded data. Currently
%           the tree is just an m-nary decision tree. The user is prompted
%           to save the tree once classification is done. Also displays a
%           graphical representation of the tree to the user
% #14 - CalculateFeatures:
%           This function will take in a data matrix where the rows 
%           represent individual samples and the columns represent the 
%           channels. Classification features will be calculated on the 
%           samples, in groups, whose size is defined by the sampleSize 
%           variable inside of this method. The resulting featureMatrix 
%           will have the same number of rows as the number of groups and 
%           (number of features)*(number of channels) columns
% #15 - DisplayTreeInfo:
%           Displays which subjects and activities were used to train the 
%           classification tree and which activities were
% #16 - LoadTreeButton_Callback:
%           Prompts the user to specify a file where a classification tree
%           (generated by the Classify button) is stored. Validates the
%           file and loads the classification tree into the handles
%           structure
% #17 - TreeInfoText_CreateFcn:
%           Adjusts the TreeInfoText colors for Windows machines
% #18 - LoadTestDataButton_Callback:
%           First prompts the user to specify a file where test data is
%           stored. The knee angle channel for the data and the
%           predicted activity for each point of the test data are graphed.
%           A classification tree must be loaded prior to calling this
%           function
% #19 - ViewTreeButton_Callback:
%           Displays a graphical representation of the classification tree
% #20 - DisplayConfusionMatrix:
%           Displays a confusion matrix of the classification tree with the
%           given training data
% #21 - PredictionArrayToMatrix:
%           Helper function for DisplayConfusionMatrix that converts a
%           classification vector into a classification matrix that can be
%           used for generation a confusion matrix. A classification matrix
%           is m x n where m is the number of activities and n is the
%           number of training samples. Each column of the matrix has a 1
%           in the row that corresponds to the activity of the current
%           sample and a 0 everywhere else.
% #22 - ChannelPopUp_Callback:
%           Called when the user makes a selection through the Channel 
%           popup. Graphs the requested subject/trial/activity/channel 
%           combination if a proper channel is picked.
% #23 - ChannelPopUp_CreateFcn:
%           Adjusts the ChannelPopUp colors for Windows machines
% #24 - LoadConfigButton_Callback:
%           Loads the configuration file specified by the user and
%           populates the handle structure with the proper values
% #25 - NewConfigButton_Callback:
%           Launces a new ConfigGUI and creates a configuration file to use
%           for learning
% #26 - ClearAxes:
%           Clears the passed in axes, along with the title and axis labels
% #27 - TestChannelPopUp_Callback:
%           Graphs the selected channel from the test data
% #28 - TestChannelPopUp_CreateFcn:
%           Adjusts the TestChannelPopUp colors for Windows machines
% #29 - PlotTestData:
%           Plot the test data based on the selected channel. If passed in
%           the expected classification for the data, we can color code it
% #30 - EditConfigButton_Callback:
%           Asks the user to load a config file and launches the Config GUI
%           to let the user edit the config file
% #31 - WindowWidthPopUp_Callback:
%           Changes the window width to use for classification based on the
%           selection
% #32 - WindowWidthPopUp_CreateFcn:
%           Adjusts the WindowWidthPopUp colors for Windows machines
% #33 - TestLabeledDataButton_Callback:
%           Asks the user for a directory of data files and loads all of
%           the data from them. Then asks the user to select which
%           subjects/activities to use for testing and runs the predict
%           function on that data, outputing the percent error
% #34 - LoadDataFromDirectory:
%           Helper function that asks the user for a folder and loads all 
%           of the data files in that folder. The function returns a
%           database structure and an activities cell array that can then
%           be used for the handles structure or the labeled test data
% #35 - CalculateFullFeatureMatrix:
%           Helper function to calculate the full feature matrix, full
%           classification vector, the subjects used, the activities used,
%           and a data stream given a database of activity data. Needs a
%           database of activities, an activies list, a list of valid
%           subjects, a list of valid activities and the windows width as
%           parameters
% #36 - GetSubjectsActivitiesFromUser:
%           Helper function to get all of the subjects and activities the
%           user would like to use for classification
% #37 - PlotPrediction:
%           Plots the prediction given the current handles structure and
%           feature matrix. The plots are color-coded based on the activity
%           number. Also prints out the classification error if the data is
%           labeled
% #38 - AnalyzeFeaturesButton_Callback:
%           Launches the AnalyzeFeaturesGUI to provide the user greater
%           visual representations of the data
% #39 - RemoveOutliers
%             % Eliminate any training data windows that are 
%               clearly non-representative of their activity. 

% ---  #1 --- %
function varargout = LearningGUIShapelet(varargin)
    % LEARNINGGUI MATLAB code for LearningGUI.fig
    %      LEARNINGGUI, by itself, creates a new LEARNINGGUI or raises the existing
    %      singleton*.
    %
    %      H = LEARNINGGUI returns the handle to a new LEARNINGGUI or the handle to
    %      the existing singleton*.
    %
    %      LEARNINGGUI('CALLBACK',hObject,eventData,handles,...) calls the local
    %      function named CALLBACK in LEARNINGGUI.M with the given input arguments.
    %
    %      LEARNINGGUI('Property','Value',...) creates a new LEARNINGGUI or raises the
    %      existing singleton*.  Starting from the left, property value pairs are
    %      applied to the GUI before LearningGUI_OpeningFcn gets called.  An
    %      unrecognized property name or invalid value makes property application
    %      stop.  All inputs are passed to LearningGUI_OpeningFcn via varargin.
    %
    %      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
    %      instance to run (singleton)".
    %
    % See also: GUIDE, GUIDATA, GUIHANDLES

    % Edit the above text to modify the response to help LearningGUI

    % Last Modified by GUIDE v2.5 24-Dec-2013 12:35:39

    % Begin initialization code - DO NOT EDIT
    gui_Singleton = 1;
    gui_State = struct('gui_Name',       mfilename, ...
                       'gui_Singleton',  gui_Singleton, ...
                       'gui_OpeningFcn', @LearningGUI_OpeningFcn, ...
                       'gui_OutputFcn',  @LearningGUI_OutputFcn, ...
                       'gui_LayoutFcn',  [] , ...
                       'gui_Callback',   []);
    if nargin && ischar(varargin{1})
        gui_State.gui_Callback = str2func(varargin{1});
    end

    if nargout
        [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
    else
        gui_mainfcn(gui_State, varargin{:});
    end
    
    % End initialization code - DO NOT EDIT
end

% ---  #2 --- %
function LearningGUI_OpeningFcn(hObject, ~, handles, varargin)
    % This function has no output args, see OutputFcn.
    % hObject    handle to figure
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    % varargin   command line arguments to LearningGUI (see VARARGIN)

    % Choose default command line output for LearningGUI
    handles.output = hObject;
    
    % Initialize data structures to their initial values
    
    % This stores all of the subject/trial/activity data for the training.
    % Populated using the Load Data button
    handles.database = {};
    
    % A cell array of activities to be used for training/testing. Populated
    % through either Load Data in the training pane, or Load Tree in the
    % testing pane
    handles.activities = {};
    
    % The current subject selected using the SubjectPopUp
    handles.currentSubject = 0;
    
    % The current trial selected using the TrialPopUp
    handles.currentTrial = 0;
    
    % The number of the current activity selected using the ActivityPopUp.
    % This is the index of the activity in the activities cell array
    handles.currentActivityNumber = 0;
    
    % The current channel selected using the ChannelPopUp
    handles.currentChannel = 0;
    
    % The tree structure generated through the Classify button. Can also be
    % loaded using the Load Tree button
    handles.tree = [];
    
    % The full classification vector calculated during Classify. Is loaded
    % when Load Tree is called to use for View Tree
    handles.fullClassificationVector = {};
    
    % A matrix that represents the entire test data. Populated when Load
    % Test Data is pressed in the testing panel
    handles.testData = [];
    
    % The expected matrix calculated during Classify. Needed for the View
    % Tree button and is also loaded when Load Tree is pressed
    handles.expectedMatrix = [];
    
    % The predicted matrix calculated during Classify. Needed for the View
    % Tree button and is also loaded when Load Tree is pressed
    handles.predictedMatrix = [];
    
    % Define a feature array at the top level in order to use it everywhere
    % in the same order. Each one of these features must have a
    % corresponding function defined somewhere in MATLAB. It can either be
    % a standard MATLAB function or a user-defined function. If the
    % function is defined by the user then it has to be in the same
    % directory as the GUI. All functions listed here must work by calling
    % them with fun(A), where A is a vector of data points. For example,
    % 'mean' is an allowable function since you would call 'mean' simply by
    % doing 'mean(A)'. This would also be nice to expose to the user
    % eventually and even allow the user to dynamically add features
    handles.featureArray = {'max';'min';'range';'mean';'std';'calcFFT';'FFT_mod';'skewness';'kurtosis'};
    
    % Fill in the FeaturesTable with the above features (and their 
    % derivatives)as column names
    diffFeatureArray = cell(length(handles.featureArray),1);
    for feature = 1:length(handles.featureArray)
        diffFeatureArray{feature} = ['derivative_', handles.featureArray{feature}];
    end
    set(handles.FeaturesTable, 'ColumnName', ...
        vertcat(handles.featureArray, diffFeatureArray));
    set(handles.FeaturesTable, 'Data', []);
    
    % Save these in the root directory so that they can be accessed from
    % any GUI
    
    % The sampling rate used for training/testing. Is specified using the
    % config file and loaded with either Load Config in training or Load
    % Tree in testing
    setappdata(0, 'samplingRate', 0);
    
    % A cell array that holds the names of the channels used for
    % classification. Loaded with the config file in the training panel or
    % when Load Tree is pressed in the testing panel
    setappdata(0, 'channelNames', {});
    
    % A vector that holds all of the subject numbers that can be selected
    % using the ClassifyGUI. Loaded when Classify is called
    setappdata(0, 'selectableSubjects', []);
    
    % A vector that holds the indices of all the subjects selected using 
    % the ClassifyGUI. These indices index into selectableSubjects
    setappdata(0, 'selectedSubjects', []);
    
    % A cell array that holds all of the activites that can be selected
    % using the ClassifyGUI. Loaded when Classify is clicked
    setappdata(0, 'selectableActivities', {});
    
    % A vector that holds the indices of all the activities selected using 
    % the ClassifyGUI. These indices index into selectableActivities
    setappdata(0, 'selectedActivities', []);
    
    % A cell array that holds all of the features that can be selected
    % using the ClassifyGUI. Loaded when Classify is clicked
    setappdata(0, 'selectableFeatures', {});
    
    % A vector that holds the indices of all the features selected using 
    % the ClassifyGUI. These indices index into selectableFeatures
    setappdata(0, 'selectedFeatures', []);
    
    % The window width to use for clasification. Set by the user using the
    % WindowWidthPopUp prior to clicking Classify
    handles.trainingWindowWidth = 1;
    
    % The window width to use for testing. Set by Classify or by Load Tree
    handles.testingWindowWidth = 1;
    
    % Record the activities used for testing
    handles.activitiesUsed = {};
    
    % A classification vector to test labeled data
    handles.testingClassificationVector = {};
    
    % A feature vector that has to be used for testing since some features
    % might not have been used when making the tree
    handles.testingFeatures = {};
    
    % If testingMode is 1, we can only select subjects and activities
    % through the ClassifyGUI and everything else is disabled
    setappdata(0, 'testingMode', 0);
    
    % If automatedTraining is 1, several trees will be generated and the
    % best returned. The types of trees to generate will be specified by
    % the ClasifyGUI
    setappdata(0, 'automatedTraining', 0);
    
    % The number of subjects to use for automated training. If this is set
    % to 0, it means that all possible numbers of subjects should be tried
    setappdata(0, 'numAutomatedSubjects', -1);
    
    % The number of features to use for automated training. If this is set
    % to 0, it means that all possible numbers of features should be tried
    setappdata(0, 'numAutomatedFeatures', -1);
    
    % Update handles structure
    guidata(hObject, handles);

    % UIWAIT makes LearningGUI wait for user response (see UIRESUME)
    % uiwait(handles.figure1);
end

% ---  #3 --- %
function varargout = LearningGUI_OutputFcn(~, ~, handles) 
    % varargout  cell array for returning output args (see VARARGOUT);
    % hObject    handle to figure
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    % Get default command line output from handles structure
    varargout{1} = handles.output;
end

% ---  #4 --- %
function LoadDataButton_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to LoadDataButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Do nothing if we haven't loaded the config file yet
    if (isempty(getappdata(0, 'channelNames')))
        errordlg('Must first load config file!', 'Load Data Error');
        return;
    end
    
    % Reset the data structures
    [database, activities] = LoadDataFromDirectory({});
    handles.database = database;
    handles.activities = activities;
    
    % Once all of the data has been parsed, we want to populate the
    % subjects pop up
    % Preallocate based on the number of nonempty values
    popUpString = cell(1, sum(~cellfun(@isempty, handles.database)) + 1);
    popUpString{1} = 'Subject #';
    popUpIndex = 2;
    for index = 1:length(handles.database)
        if (~isempty(handles.database{index}))
            popUpString{popUpIndex} = num2str(index);
            popUpIndex = popUpIndex + 1;
        end
    end
    set(handles.SubjectPopUp, 'String', popUpString);
    set(handles.SubjectPopUp, 'Enable', 'on');
    set(handles.SubjectPopUp, 'Value', 1);
    
    % Make sure the trial and activity popups are reset
    set(handles.TrialPopUp, 'Enable', 'off');
    set(handles.TrialPopUp, 'Value', 1);
    set(handles.ActivityPopUp, 'Enable', 'off');
    set(handles.ActivityPopUp, 'Value', 1);
    
    % Update handles structure
    guidata(hObject, handles);
end

% ---  #5 --- %
function SubjectPopUp_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to SubjectPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Clear the graph since we'll need to invalidate the below popups
    ClearAxes(handles.ActivityAxes);
    set(handles.ActivityPopUp, 'Value', 1);
    set(handles.ActivityPopUp, 'Enable', 'off');
    handles.currentActivityNumber = 0;
    set(handles.ChannelPopUp, 'Value', 1);
    set(handles.ChannelPopUp, 'Enable', 'off');
    handles.currentChannel = 0;
    
    contents = cellstr(get(handles.SubjectPopUp, 'String'));
    selectionIndex = get(handles.SubjectPopUp, 'Value');
    
    % If the user selected 'Subject #' then we want to reset everything
    % (this will always be the first selection in the pop-up)
    if (selectionIndex == 1)
        handles.currentSubject = 0;
        set(handles.TrialPopUp, 'Value', 1);
        set(handles.TrialPopUp, 'Enable', 'off');
        handles.currentTrial = 0;
    else
        % Otherwise we want to populate the trial popup
        subject = str2double(contents{selectionIndex});
        popUpString = cell(1, sum(~cellfun(@isempty, handles.database{subject})) + 1);
        popUpString{1} = 'Trial #';
        popUpIndex = 2;
        for index = 1:length(handles.database{subject})
            if ~isempty(handles.database{subject}{index})
                popUpString{popUpIndex} = num2str(index);
                popUpIndex = popUpIndex + 1;
            end
        end
        set(handles.TrialPopUp, 'String', popUpString);
        set(handles.TrialPopUp, 'Enable', 'on');
        set(handles.TrialPopUp, 'Value', 1);
        handles.currentSubject = subject;
    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% ---  #6 --- %
function SubjectPopUp_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to SubjectPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: popupmenu controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% ---  #7 --- %
function TrialPopUp_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to TrialPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Clear the graph since we'll need to invalidate the below popups
    ClearAxes(handles.ActivityAxes);
    set(handles.ChannelPopUp, 'Value', 1);
    set(handles.ChannelPopUp, 'Enable', 'off');
    handles.currentChannel = 0;
    
    contents = cellstr(get(handles.TrialPopUp, 'String'));
    selectionIndex = get(handles.TrialPopUp, 'Value');
    
    % If the user selected 'Trial #' then we want to reset the activity
    % name (this will always be the first selection in the pop-up)
    if (selectionIndex == 1)
        handles.currentTrial = 0;
        set(handles.ActivityPopUp, 'Value', 1);
        set(handles.ActivityPopUp, 'Enable', 'off');
        handles.currentActivityNumber = 0;
    else
        % Otherwise we want to populate the activity name popup
        subject = handles.currentSubject;
        trial = str2double(contents{selectionIndex});
        
        % This is here to make sure that Activity Name is always first
        % after the activities have been sorted
        popUpString = cell(1, sum(~cellfun(@isempty, handles.database{subject}{trial})) + 1);
        popUpString{1} = '';
        popUpIndex = 2;
        for index = 1:length(handles.database{subject}{trial})
            if ~isempty(handles.database{subject}{trial}{index})
                popUpString{popUpIndex} = char(handles.activities(index));
                popUpIndex = popUpIndex + 1;
            end
        end
        % This needs to be sorted since the activities cell array is not
        % guaranteed to be in sorted order
        popUpString = sort(popUpString);
        popUpString{1} = 'Activity Name';
        
        set(handles.ActivityPopUp, 'String', popUpString);
        set(handles.ActivityPopUp, 'Enable', 'on');
        set(handles.ActivityPopUp, 'Value', 1);
        handles.currentTrial = trial;
    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% ---  #8 --- %
function TrialPopUp_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to TrialPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: popupmenu controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% ---  #9 --- %
function ActivityPopUp_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to ActivityPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Clear the graph since we'll need to invalidate the activity popup
    ClearAxes(handles.ActivityAxes);
    
    contents = cellstr(get(handles.ActivityPopUp, 'String'));
    selectionIndex = get(handles.ActivityPopUp, 'Value');
    
    % If the user selected 'Activity Name' then we want to reset the 
    % channel (this will always be the first selection in the pop-up)
    if (selectionIndex == 1)
        handles.currentActivityNumber = 0;
        set(handles.ChannelPopUp, 'Value', 1);
        set(handles.ChannelPopUp, 'Enable', 'off');
        handles.currentChannel = 0;
    else
        % Otherwise we want to populate the channel popup
        % This is here to make sure that Channel is always first
        channelNames = getappdata(0, 'channelNames');
        popUpString = cell(1, length(channelNames) + 1);
        popUpString{1} = 'Channel';
        for channelNumber = 1:length(channelNames)
            popUpString{channelNumber + 1} = char(channelNames{channelNumber});
        end
        
        set(handles.ChannelPopUp, 'String', popUpString);
        set(handles.ChannelPopUp, 'Enable', 'on');
        set(handles.ChannelPopUp, 'Value', 1);
        activityIndex = find(ismember(handles.activities, contents{selectionIndex}));
        
        handles.currentActivityNumber = activityIndex;
    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% --- #10 --- %
function ActivityPopUp_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to ActivityPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: popupmenu controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% --- #11 --- %
function GraphActivity(handles)
    % handles - needed to access database and activities
    
    % We've saved the subject/trial/activity/channel information into the
    % handles structure so we can simply access the data
    
    if (handles.currentSubject > 0 && handles.currentTrial > 0 && ...
            handles.currentActivityNumber > 0 && handles.currentChannel > 0)

        data = handles.database{handles.currentSubject}{handles.currentTrial}{handles.currentActivityNumber};

        % Switch over to the current activity axes and plot the data
        timeVector = MakeTimeVector(size(data, 1), 1/getappdata(0, 'samplingRate'));
        axes(handles.ActivityAxes);
        cla;
        hold on;
        plot(timeVector, data(:,handles.currentChannel));
        xlabel('Time (seconds)');
        channelNames = getappdata(0, 'channelNames');
        ylabel(char(channelNames{handles.currentChannel}));
        title(['Subject ', num2str(handles.currentSubject),...
            ' Trial ', num2str(handles.currentTrial), ' - ', ...
            handles.activities{handles.currentActivityNumber}]);
        
        % Add lines for the window width
        maxTime = max(timeVector);
        yLimits = get(handles.ActivityAxes, 'YLim');
        for xVal = 0:handles.trainingWindowWidth:maxTime
            line([xVal xVal], yLimits, 'Color', 'r');
        end
        
        % Finally calculate the features for this channel on each window
        % and add that to the features table
        plottedData = data(:,handles.currentChannel);
        numWindows = floor(maxTime/handles.trainingWindowWidth);
        sampleSize = getappdata(0, 'samplingRate') * handles.trainingWindowWidth;
        featureMatrix = zeros(numWindows, 2*length(handles.featureArray));
        
        featureCalculatingWaitbar = waitbar(0, 'Calculating features');
        
        for window = 1:numWindows
            waitbar(window/numWindows, featureCalculatingWaitbar);
            % Get the subset of the data that we will be working on 
            dataWindow = plottedData((sampleSize*(window - 1) + 1):...
                sampleSize*window);
            diffDataWindow = diff(dataWindow); %#ok<NASGU> Used in call to eval below
            for feature = 1:length(handles.featureArray)
                featureMatrix(window, feature) = ...
                    eval([char(handles.featureArray(feature)),'(dataWindow)']);
                featureMatrix(window, feature + length(handles.featureArray)) = ...
                    eval([char(handles.featureArray(feature)),'(diffDataWindow)']);
            end
        end
        
        delete(featureCalculatingWaitbar);
        
        set(handles.FeaturesTable, 'Data', featureMatrix);
    end
end

% --- #12 --- %
function timeVector = MakeTimeVector(totalTimesteps, timeDelta)
    
    timeVector = zeros(1, totalTimesteps);
    
    for time = 1:totalTimesteps
        timeVector(time) = timeDelta * time;
    end
end

% --- #13 --- %
function ClassifyButton_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to ClassifyButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Do nothing if we haven't populated the data yet
    if (isempty(handles.database))
        errordlg('Must first load data!', 'Classify Error');
        return;
    end
    
    [validSubjects, validActivities, validFeatures, SAXWindowWidth, ...
    SAXCardinality, numCandidatesPerClass, minShapelet, maxShapelet] = ...
    GetSubjectsActivitiesFromUser(handles.database, handles.activities, handles.featureArray, 0);
    
    if (~(isempty(validSubjects) || isempty(validActivities) || isempty(validFeatures)))
        
        [fullShapeletMatrix, fullFeaturesMatrix, fullClassificationVector, ...
        subjectsUsed, activitiesUsed, ~, ~] = CalculateFullFeatureMatrix(handles.database, ...
        handles.activities, validSubjects, validActivities, ...
        handles.trainingWindowWidth, handles.featureArray, validFeatures);
    
        % Once the full feature matrix has been calculated we need to
        % remove any data points that are outside of 3 sds
        [fullShapeletMatrix, fullFeaturesMatrix, fullClassificationVector] ...
            = RemoveOutliers(fullShapeletMatrix, fullFeaturesMatrix, ...
            fullClassificationVector, activitiesUsed);
    
        % We need to create the predictor names for all of the data
        channelNames = getappdata(0, 'channelNames');
        numChannels = length(channelNames);
        % 2 needed since we have both regular and derivative features
        predictorNames = cell(1, 2 * numChannels * sum(validFeatures));
        predictorIndex = 1;
        for channel = 1:numChannels
            for feature = 1:length(handles.featureArray)
                if (validFeatures(feature) == 1)
                    predictorNames{predictorIndex} = [char(channelNames{channel}),...
                        '_', char(handles.featureArray{feature})];
                    predictorIndex = predictorIndex + 1;
                end
            end
        end
        for channel = 1:numChannels
            for feature = 1:length(handles.featureArray)
                if (validFeatures(feature) == 1)
                    predictorNames{predictorIndex} = [char(channelNames{channel}),...
                        '_derivative_', char(handles.featureArray{feature})];
                    predictorIndex = predictorIndex + 1;
                end
            end
        end

        
        % Check if we are doing cross validation
        crossVal = getappdata(0, 'crossValidationEnabled');
        if (~crossVal)
            % Get the tree depth and class threshold from ClassifyGUI
            treeDepth = getappdata(0, 'treeDepth');
            thresholdValue = getappdata(0, 'classThresholdValue');
        else
            % TODO: Figure out how to make this feasible
            
%             % Here we are performing cross validation
%             bestErrorSum = NaN;
%             treeDepth = 0;
%             thresholdValue = 0;
%             
%             % Now we will want to try every possible combination of
%             % parameters and choose the best tree out of those
%             for depth = 4:10
%                 for threshold = 0.80:0.05:0.95
%                     
%                     % The first thing we need to do is randomly permute the 
%                     % rows of the feature matrix
%                     indices = randperm(size(fullFeatureMatrix, 1));
%                     cvFeatureMatrix = fullFeatureMatrix(indices, :);
%                     cvClassificationVector = fullClassificationVector(indices);
%                     kfoldIndex = round(size(cvFeatureMatrix, 1) / 10);
%                     
%                     errorSum = 0;
%                     
%                     for fold = 1:10
%                         % Form the training and validation data for this
%                         % combination of parameters
%                         validationFeatureMatrix = cvFeatureMatrix(1:kfoldIndex, :);
%                         validationClassificationVector = cvClassificationVector(1:kfoldIndex);
%                         trainingIndices = (kfoldIndex + 1):size(cvFeatureMatrix, 1);
%                         trainingFeatureMatrix = cvFeatureMatrix(trainingIndices, :);
%                         trainingClassificationVector = cvClassificationVector(trainingIndices);
%                         
%                         % Now train the tree
%                         tree = fitTreeShapelet(activitiesUsed, predictorNames, ...
%                             trainingClassificationVector, trainingFeatureMatrix, ...
%                             depth, threshold);
%                         
%                         % Calculate the error on the validation data
%                         [~, ~, foldError, unknownPercent] = classifyData(tree, validationFeatureMatrix, ....
%                             activitiesUsed, true, 0.75, validationClassificationVector);
%                         
%                         % Add a penalty for unknown classification
%                         errorSum = errorSum + foldError + 0.1 * unknownPercent;
%                         
%                         % Put the two matrices back together with the
%                         % validation data now at the bottom
%                         cvFeatureMatrix = [trainingFeatureMatrix; validationFeatureMatrix];
%                         cvClassificationVector = [trainingClassificationVector, validationClassificationVector];
%                         
%                         disp(['Depth: ', num2str(depth), ' threshold: ', num2str(threshold),...
%                             ' fold: ', num2str(fold), ' error: ', num2str(foldError),...
%                             ' unknown percentage: ', num2str(unknownPercent * 100), '%']);
%                     end
%                     
%                     disp(['Depth: ', num2str(depth), ' threshold: ', num2str(threshold),...
%                         ' final error: ', num2str(errorSum)]);
%                     
%                     % Record the current configuration if it produces the
%                     % lowest error
%                     if (isnan(bestErrorSum) || errorSum < bestErrorSum)
%                         bestErrorSum = errorSum;
%                         treeDepth = depth;
%                         thresholdValue = threshold;
%                         disp('Found better configuration!');
%                     end
%                 end
%             end
%             
%             setappdata(0, 'treeDepth', treeDepth);
%             setappdata(0, 'classThresholdValue', thresholdValue);
        end
        
        % Next we need to convert the shapelet matrix into SAX
        [SAXMatrix, ~, distMat] = TransformToSAX(fullShapeletMatrix, ...
            numChannels, SAXWindowWidth, SAXCardinality);
        
        classifyWaitbar = waitbar(0, 'Creating classification tree...');
        % Now that the tree depth and classification threshold have been 
        % set (emperically or by cross validation), train the final tree
        samplingRate = getappdata(0, 'samplingRate');
        
        classificationTree = fitTreeShapeletSAX(activitiesUsed, fullClassificationVector, ...
            SAXMatrix, fullFeaturesMatrix, predictorNames, numCandidatesPerClass, ...
            minShapelet, maxShapelet, (samplingRate / SAXWindowWidth) / 10, ...
            numChannels, treeDepth, thresholdValue, distMat);
        delete(classifyWaitbar);

        handles.tree = classificationTree;
        handles.fullFeaturesMatrix = fullFeaturesMatrix;
        handles.SAXMatrix = SAXMatrix;
        handles.distMat = distMat;
        handles.fullClassificationVector = fullClassificationVector;

        % Extra items that we want to save along with the tree
        handles.activitiesUsed = activitiesUsed;
        handles.SAXWindowWidth = SAXWindowWidth;
        handles.SAXCardinality = SAXCardinality;
        handles.numCandidatesPerClass = numCandidatesPerClass;
        handles.minShapelet = minShapelet; 
        handles.maxShapelet = maxShapelet;
        
        channelNames = getappdata(0, 'channelNames'); %#ok<NASGU> Used in save call below

        % Calculate the expected and predicted matrices to use for displaying
        % the confusion matrix later
        predictedActivities = classifyDataShapelet(classificationTree, ...
            fullFeaturesMatrix, SAXMatrix, activitiesUsed, numChannels, ...
            0, 0, fullClassificationVector, distMat);

        % Transform the predicted and expected vectors to matrices
        expectedMatrix = PredictionArrayToMatrix(fullClassificationVector,...
            activitiesUsed, 'expected data array');
        predictedMatrix = PredictionArrayToMatrix(predictedActivities, ...
            activitiesUsed, 'predicted data array');

        handles.expectedMatrix = expectedMatrix;
        handles.predictedMatrix = predictedMatrix;

        % Save the window width to use for testing
        handles.testingWindowWidth = handles.trainingWindowWidth;
        testingWindowWidth = handles.testingWindowWidth; %#ok<NASGU> Used in save call below
        
        % Create the testing features array
        for feature = 1:length(handles.featureArray)
            if (validFeatures(feature) == 1)
                handles.testingFeatures{length(handles.testingFeatures) + 1} = ...
                    handles.featureArray{feature};
            end
        end
        testingFeatures = handles.testingFeatures;

        % We need to save this tree into a file in order to use it later
        % We also need to save all of the subjects, trials and activities being
        % used. For now, just save everything since we are using all subjects,
        % trials and activities. THIS WILL HAVE TO BE CHANGED LATER
        % Also save the full feature matrix and the full classification matrix
        % since we will need it later to calculate classification error and the
        % confusion matrix
        [filename, pathname] = uiputfile('*.mat', 'Save Classification Tree As');
        if (filename == 0)
            warndlg('Improper file specified. Tree will not be saved.', 'Classify Warning');
        else
            % Only save if the user specified a proper file
            save([pathname, filename], 'classificationTree', 'subjectsUsed', ...
                'activitiesUsed', 'fullFeaturesMatrix', 'fullClassificationVector', ...
                'samplingRate', 'channelNames', 'predictedMatrix', 'expectedMatrix', ...
                'testingWindowWidth', 'testingFeatures', 'treeDepth', 'thresholdValue', ...
                'crossVal', 'SAXMatrix', 'SAXWindowWidth', 'SAXCardinality', ...
                'numCandidatesPerClass', 'minShapelet', 'maxShapelet', 'distMat');
        end

        % Now that classification is done we need to display the information
        % about it to the user
        DisplayTreeInfo(subjectsUsed, activitiesUsed, testingFeatures, handles);

        % Display the final tree to the user
        ViewTree(classificationTree, predictorNames, activitiesUsed);

        % Display the confusion matrix to the user
        DisplayConfusionMatrix(handles);

        % Update handles structure
        guidata(hObject, handles);

    end
end

% --- #14 --- %
function [shapeletMatrix, featureMatrix] = CreateFeatureDataMatrix(data, ...
    windowWidth, featureArray, validFeatures, useWaitbar)

    sampleSize = getappdata(0, 'samplingRate') * windowWidth;
    numOfWindows = floor(size(data, 1) / sampleSize);
    numChannels = size(data, 2);
    numOfFeatures = sum(validFeatures);
    
    shapeletMatrix = zeros(numOfWindows, sampleSize * numChannels);
    featureMatrix = zeros(numOfWindows, 2 * numOfFeatures * numChannels);
    
    if (useWaitbar)
        featureCalculatingWaitbar = waitbar(0, 'Calculating feature matrices');
    end
    
    for windowNumber = 1:numOfWindows
        if (useWaitbar)
            waitbar(windowNumber / numOfWindows, featureCalculatingWaitbar);
        end
        % Get the subset of the data that we will be working on 
        dataWindow = data((sampleSize*(windowNumber - 1) + 1):sampleSize*windowNumber,:);
        
        for channel = 1:numChannels
            shapeletMatrix(windowNumber, ((channel - 1) * sampleSize + 1): ...
                (channel * sampleSize)) = dataWindow(:, channel);
        
            % Calculate features for regular data
            dataVector = dataWindow(:,channel);
            featureCount = 1;
            for feature = 1:length(featureArray)
                if (validFeatures(feature) == 1)
                    featureMatrix(windowNumber, numOfFeatures * (channel - 1)...
                        + featureCount) = eval([char(featureArray(feature)),'(dataVector)']);
                    featureCount = featureCount + 1;
                end
            end

            % Calculate features for derivative
            diffDataVector = diff(dataVector); %#ok<NASGU> Used in eval call below
            featureCount = 1;
            for feature = 1:length(featureArray)
                if (validFeatures(feature) == 1)
                    featureMatrix(windowNumber, numOfFeatures * (numChannels + channel - 1)...
                        + featureCount) = eval([char(featureArray(feature)),'(diffDataVector)']);
                    featureCount = featureCount + 1;
                end
            end
        end
    end
    
    if (useWaitbar)
        delete(featureCalculatingWaitbar);
    end
end

% --- #15 --- %
function DisplayTreeInfo(subjectsUsed, activitiesUsed, testingFeatures, handles)
    % Display information about the current tree to the TreeInfoText
    % textbox
    % subjectsUsed - the subject/trial combinations used for making the
    % tree, as a cell array of strings
    % activitiesUsed - the activities used for making the tree, a cell
    % array of strings
    % handles - handles object to get access to TreeInfoTextxs
    
    % First calculate the full classification error on the training set
    channelNames = getappdata(0, 'channelNames');
    numChannels = length(channelNames);
    
    [~, ~, classificationError] = classifyDataShapelet(handles.tree, ...
            handles.fullFeaturesMatrix, handles.SAXMatrix, activitiesUsed, ...
            numChannels, 0, 0, handles.fullClassificationVector, handles.distMat);
    
    % Preallocate the cell array
    treeInfoString = cell(1, 19 + length(subjectsUsed) + ...
        length(activitiesUsed) + length(testingFeatures));
    
    treeInfoString{1} = 'Training classification error:';
    treeInfoString{2} = ...
        [num2str(classificationError * 100), '%'];
    treeInfoString{3} = '';
    
    treeInfoString{4} = 'Tree depth:';
    treeInfoString{5} = num2str(getappdata(0, 'treeDepth'));
    treeInfoString{6} = '';
    
    treeInfoString{7} = 'Class threshold:';
    treeInfoString{8} = [num2str(getappdata(0, 'classThresholdValue') * 100), '%'];
    treeInfoString{9} = '';
    
    treeInfoString{10} = ['SAX window width: ', num2str(handles.SAXWindowWidth)];
    treeInfoString{11} = ['SAX cardinality: ', num2str(handles.SAXCardinality)];
    treeInfoString{12} = ['Num candidates per class: ', num2str(handles.numCandidatesPerClass)];
    treeInfoString{13} = ['Shapelet lengths: ', num2str(handles.minShapelet), ...
        ' - ', num2str(handles.maxShapelet)];
    treeInfoString{14} = '';
    
    treeInfoString{15} = 'Subjects used:';
    
    for subject = 1:length(subjectsUsed)
        treeInfoString{subject + 15} =  subjectsUsed{subject};
    end
    
    treeInfoString{length(subjectsUsed) + 16} = '';
    treeInfoString{length(subjectsUsed) + 17} = 'Activities used:';
    
    for activity = 1:length(activitiesUsed)
        % Find the index to display that along with the activity name
        treeInfoString{activity + length(subjectsUsed) + 17} = ...
            [activitiesUsed{activity}, ' (', num2str(activity), ')'];
    end
    
    treeInfoString{length(activitiesUsed) + length(subjectsUsed) + 18} = '';
    treeInfoString{length(activitiesUsed) + length(subjectsUsed) + 19} = 'Features used:';
    
    for feature = 1:length(testingFeatures)
        % Find the index to display that along with the feature name
        treeInfoString{feature + length(activitiesUsed) + ...
            length(subjectsUsed) + 19} = testingFeatures{feature};
    end
    
    set(handles.TreeInfoText, 'String', treeInfoString);
    
    % Populate the TestChannelPopUp
    set(handles.TestChannelPopUp, 'String', getappdata(0, 'channelNames'));
    set(handles.TestChannelPopUp, 'Enable', 'on');
end

% --- #16 --- %
function LoadTreeButton_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to LoadTreeButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Asks the user for a file and load all of the tree data from that file
    [filename, pathname] = uigetfile('*mat', 'Load Tree File');
    if (filename == 0)
        % The user closed the dialog box so just return
        return;
    else
        % Load all of the data from the file
        treeFileData = load([pathname, filename]);
        % Check to make sure the required data is in the file
        fields = fieldnames(treeFileData);
        if (ismember({'subjectsUsed', 'classificationTree', 'activitiesUsed',...
                'fullFeaturesMatrix', 'fullClassificationVector', 'samplingRate',...
                'channelNames', 'predictedMatrix', 'expectedMatrix', ...
                'testingWindowWidth', 'testingFeatures', 'treeDepth', ...
                'thresholdValue', 'crossVal', 'SAXMatrix', 'SAXWindowWidth', ...
                'SAXCardinality', 'numCandidatesPerClass', 'minShapelet', ...
                'maxShapelet', 'distMat'}, fields));            
            
            % Save the tree in the handles structure and display tree
            % information
            handles.tree = treeFileData.classificationTree;
            handles.fullFeaturesMatrix = treeFileData.fullFeaturesMatrix;
            handles.fullClassificationVector = treeFileData.fullClassificationVector;
            setappdata(0, 'samplingRate', treeFileData.samplingRate);
            setappdata(0, 'channelNames', treeFileData.channelNames);
            setappdata(0, 'treeDepth', treeFileData.treeDepth);
            setappdata(0, 'classThresholdValue', treeFileData.thresholdValue);
            setappdata(0, 'crossValidationEnabled', treeFileData.crossVal);
            handles.predictedMatrix = treeFileData.predictedMatrix;
            handles.expectedMatrix = treeFileData.expectedMatrix;
            handles.testingWindowWidth = treeFileData.testingWindowWidth;
            handles.activitiesUsed = treeFileData.activitiesUsed;
            handles.testingFeatures = treeFileData.testingFeatures;
            handles.SAXMatrix = treeFileData.SAXMatrix;
            handles.SAXWindowWidth = treeFileData.SAXWindowWidth;
            handles.SAXCardinality = treeFileData.SAXCardinality;
            handles.numCandidatesPerClass = treeFileData.numCandidatesPerClass;
            handles.minShapelet = treeFileData.minShapelet;
            handles.maxShapelet = treeFileData.maxShapelet;
            handles.distMat = treeFileData.distMat;
            
            setappdata(0, 'SAXWindowWidth', handles.SAXWindowWidth);
            setappdata(0, 'SAXCardinality', handles.SAXCardinality);
            setappdata(0, 'numCandidatesClass', handles.numCandidatesPerClass);
            setappdata(0, 'minShapelet', handles.minShapelet);
            setappdata(0, 'maxShapelet', handles.maxShapelet);
            
            DisplayTreeInfo(treeFileData.subjectsUsed, ...
                treeFileData.activitiesUsed, treeFileData.testingFeatures, handles);
        else
            errordlg('Improper tree file specified', 'Load Tree Error');
        end
    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% --- #17 --- %
function TreeInfoText_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to TreeInfoText (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: edit controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% --- #18 --- %
function TestDataStreamButton_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to TestDataStreamButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Check to see if we have a tree loaded first before we
    if (isempty(handles.tree))
        errordlg('Must first load a classification tree!', 'Load Test Data Error');
        return;
    end
    
    % Asks the user for a data file and load all of the data from that file
    [filename, pathname] = uigetfile('*.txt', 'Load Test Data File');
    if (filename == 0)
        % The user closed the dialog box so just return
        return;
    end
    
    testDataImportWaitbar = waitbar(0, 'Importing test data');
    
    % Load the test data from the file
    testData = importdata([pathname, filename]);
    
    delete(testDataImportWaitbar);
    
    % Verify that the test data is a proper data file
    if (size(testData, 2) ~= length(getappdata(0, 'channelNames')))
        errordlg('Improper test data file!', 'Load Test Data Error');
        return
    end
    
    % Save the test data in the handles structure
    handles.testData = testData;
    
    % Reset the classification vector since this is just a data stream
    handles.testingClassificationVector = {};
    
    % Plot the data for the given channel
    testChannel = get(handles.TestChannelPopUp, 'Value');
    PlotTestData(testChannel, handles, {});
    
    % Now we need to calculate features on this data
    [shapeletMatrix, featureMatrix] = CreateFeatureDataMatrix(testData, ...
        handles.testingWindowWidth, handles.testingFeatures, ...
        boolean(ones(1,length(handles.testingFeatures))), 1);
    
    PlotPrediction(handles, shapeletMatrix, featureMatrix, []);
    
    % Update handles structure
    guidata(hObject, handles);
end

% --- #19 --- %
function ViewTreeButton_Callback(~, ~, handles) %#ok<DEFNU>
    % hObject    handle to ViewTreeButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Checks if a tree exists and displays it to the user if it does
    if (~isempty(handles.tree))
        % We need to create the predictor names for all of the data
        channelNames = getappdata(0, 'channelNames');
        % 2 needed since we have both regular and derivative features
        predictorNames = cell(1, 2 * length(channelNames) * length(handles.testingFeatures));
        predictorIndex = 1;
        for channel = 1:length(channelNames)
            for feature = 1:length(handles.featureArray)
                predictorNames{predictorIndex} = [char(channelNames{channel}),...
                    '_', char(handles.featureArray{feature})];
                predictorIndex = predictorIndex + 1;
            end
        end
        for channel = 1:length(channelNames) 
            for feature = 1:length(handles.featureArray)
                predictorNames{predictorIndex} = [char(channelNames{channel}),...
                    '_derivative_', char(handles.featureArray{feature})];
                predictorIndex = predictorIndex + 1;
            end
        end
        
        ViewTree(handles.tree, predictorNames, handles.activitiesUsed);
        DisplayConfusionMatrix(handles);
    else
        errordlg('Must first load a classification tree!', 'View Tree Error');
    end
end

% --- #20 --- %
function DisplayConfusionMatrix(handles)

    % Make sure that a tree has already been trained
    if (~isempty(handles.tree) && ~isempty(handles.expectedMatrix) && ...
            ~isempty(handles.predictedMatrix))
        figure;
        plotconfusion(handles.expectedMatrix, handles.predictedMatrix);
    end
end

% --- #21 --- %
function predictionMatrix = PredictionArrayToMatrix(predictionArray, activityArray,...
    predictionArrayName)
    % predictionArray - a cell array where cell is a predicted activity
    % activityArray - a cell array of all the activiies used for
    %                 classification
    % predictionArrayName - prediction array name for waitbar
    predictionMatrix = zeros(length(activityArray), length(predictionArray));
    
    activityNameDict = struct;
    
    % Create a map from class names to class indices
    for activity = 1:length(activityArray)
        activityNameDict.(char(activityArray{activity})) = activity;
    end
    
    arrayToMatrixWaitbar = waitbar(0, ['Converting ', predictionArrayName, ...
        ' to matrix']);
    
    for sample = 1:length(predictionArray)
        
        waitbar(sample / length(predictionArray), arrayToMatrixWaitbar);
        
        activityIndex = activityNameDict.(char(predictionArray{sample}));
        
        predictionMatrix(activityIndex, sample) = 1;
    end
    
    delete(arrayToMatrixWaitbar);
end

% --- #22 --- %
function ChannelPopUp_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to ChannelPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Once a channel has been selected, we want to graph the
    % corresponding activity
    handles.currentChannel = get(handles.ChannelPopUp, 'Value') - 1;
    if (handles.currentChannel > 0)
        GraphActivity(handles);
    else
        ClearAxes(handles.ActivityAxes);
    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% --- #23 --- %
function ChannelPopUp_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to ChannelPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: popupmenu controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% --- #24 --- %
function LoadConfigButton_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to LoadConfigButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Asks the user for a file and load all of the config data from that file
    [filename, pathname] = uigetfile('*mat', 'Load Config File');
    if (filename == 0)
        % The user closed the dialog box so just return
        return;
    else
        % Load all of the data from the file
        configFileData = load([pathname, filename]);
        % Check to make sure the required data is in the file
        fields = fieldnames(configFileData);
        if (ismember({'channelNames', 'samplingRate'}, fields))
            
            % Record the sampling rate and the channel names
            setappdata(0, 'samplingRate', configFileData.samplingRate);
            setappdata(0, 'channelNames', configFileData.channelNames);
            
            helpdlg('Config file loaded successfully', 'Load Config');
        else
            errordlg('Improper config file specified', 'Load Config Error');
        end
    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% --- #25 --- %
function NewConfigButton_Callback(~, ~, ~) %#ok<DEFNU>
    % hObject    handle to NewConfigButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Create a new ConfigGUI
    newConfig = ConfigGUI;
    
    % Wait for the GUI to close
    waitfor(newConfig);
    
    % Check if we have set the sampling rate and channel names
    if (getappdata(0, 'samplingRate') > 0 && ~isempty(getappdata(0, 'channelNames')))
        helpdlg('Config file loaded successfully', 'New Config');
    end
end

% --- #26 --- %
function ClearAxes(graphAxes)
    axes(graphAxes);
    cla(graphAxes);
    xlabel('');
    ylabel('');
    title('');
end

% --- #27 --- %
function TestChannelPopUp_Callback(~, ~, handles) %#ok<DEFNU>
    % hObject    handle to TestChannelPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Plot the data for the given channel if it has been loaded
    if(~isempty(handles.testData))
        testChannel = get(handles.TestChannelPopUp, 'Value');
        PlotTestData(testChannel, handles, handles.testingClassificationVector);
    end
end

% --- #28 --- %
function TestChannelPopUp_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to TestChannelPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: popupmenu controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% --- #29 --- %
function PlotTestData(channel, handles, classificationVector)
    timeVector = MakeTimeVector(size(handles.testData, 1), 1/getappdata(0, 'samplingRate'));
    axes(handles.TestDataAxes);
    
    if (isempty(classificationVector))
        plot(timeVector, handles.testData(:,channel));
    else
        % We need to split the data up according to the activity and make a
        % separate plot for each. The best way to do this is to create a 
        % matrix with the same number of rows as the time vector and the 
        % same number of columns as there are activities. To start off with, 
        % we need to extend the classification vector to have the same 
        % number of points as the time vector
        extendedClassificationVector = zeros(1, length(timeVector));
        fullWindowWidth = getappdata(0, 'samplingRate') * handles.testingWindowWidth;
        
        for activity = 1:length(classificationVector)
            activityIndex = find(ismember(handles.activitiesUsed, classificationVector{activity}));
            for index = 1:fullWindowWidth
                extendedClassificationVector((activity - 1)*(fullWindowWidth) + index) = ...
                    activityIndex;
            end
        end
        
        coloringWaitbar = waitbar(0, 'Coloring data');
        
        % Now we need to go through and properly split up all of the data
        % based on the activities
        plotData = zeros(length(timeVector), length(handles.activitiesUsed));
        for activity = 1:length(handles.activitiesUsed)
            for timestep = 1:length(timeVector)
                if (activity == extendedClassificationVector(timestep))
                    plotData(timestep, activity) = handles.testData(timestep, channel);
                else
                    plotData(timestep, activity) = NaN;
                end
            end
            waitbar(activity / length(handles.activitiesUsed), coloringWaitbar);
        end
        
        delete(coloringWaitbar);
        
        plot(timeVector, plotData);
        
        % Create a legend to properly label the plotted data
        legend(handles.activitiesUsed);
    end
    
    xlabel('Time (seconds)');
    channelNames = getappdata(0, 'channelNames');
    ylabel(char(channelNames{channel}));
    title('Test data');
end

% --- #30 --- %
function EditConfigButton_Callback(~, ~, ~) %#ok<DEFNU>
    % hObject    handle to EditConfigButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Asks the user for a file and load all of the config data from that file
    [filename, pathname] = uigetfile('*mat', 'Load Config File');
    if (filename == 0)
        % The user closed the dialog box so just return
        return;
    else
        % Load all of the data from the file
        configFileData = load([pathname, filename]);
        % Check to make sure the required data is in the file
        fields = fieldnames(configFileData);
        if (ismember({'channelNames', 'samplingRate'}, fields))
            
            % Record the sampling rate and the channel names
            setappdata(0, 'samplingRate', configFileData.samplingRate);
            setappdata(0, 'channelNames', configFileData.channelNames);
            
            % Launch the ConfigGUI to edit the config file
            newConfig = ConfigGUI;

            % Wait for the GUI to close
            waitfor(newConfig);

            % Check if we have set the sampling rate and channel names
            if (getappdata(0, 'samplingRate') > 0 && ~isempty(getappdata(0, 'channelNames')))
                helpdlg('Config file loaded successfully', 'Edit Config');
            end
        else
            errordlg('Improper config file specified', 'Edit Config Error');
        end
    end
end

% --- #31 --- %
function WindowWidthPopUp_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to WindowWidthPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)

    % Adjust the training window width
    windowWidthIndex = get(handles.WindowWidthPopUp, 'Value');
    if (windowWidthIndex == 1)
        handles.trainingWindowWidth = 1;
    elseif (windowWidthIndex == 2)
        handles.trainingWindowWidth = 3;
    elseif (windowWidthIndex == 3)
        handles.trainingWindowWidth = 5;
    elseif (windowWidthIndex == 4)
        handles.trainingWindowWidth = 10;
    end
    
    % Update handles structure
    guidata(hObject, handles);
    
    GraphActivity(handles);
end

% --- #32 --- %
function WindowWidthPopUp_CreateFcn(hObject, ~, ~) %#ok<DEFNU>
    % hObject    handle to WindowWidthPopUp (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    empty - handles not created until after all CreateFcns called

    % Hint: popupmenu controls usually have a white background on Windows.
    %       See ISPC and COMPUTER.
    if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
        set(hObject,'BackgroundColor','white');
    end
end

% --- #33 --- %
function TestLabeledDataButton_Callback(hObject, ~, handles) %#ok<DEFNU>
    % hObject    handle to TestLabeledDataButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Check to see if we have a tree loaded first before we
    if (isempty(handles.tree))
        errordlg('Must first load a classification tree!', 'Load Test Data Error');
        return;
    end
    
    % Load in a folder of labeled activites
    [testDatabase,~] = LoadDataFromDirectory(handles.activitiesUsed);
    
    [validSubjects, validActivities, validFeatures] = GetSubjectsActivitiesFromUser(...
        testDatabase, handles.activitiesUsed, handles.testingFeatures, 1);
    
    if (~(isempty(validSubjects) || isempty(validActivities) || isempty(validFeatures)))  
    
        % We need to make a feature matrix and a full classification vector for
        % this test data. We also need a data stream vector for plotting the 
        % test data
        [fullShapeletMatrix, fullFeaturesMatrix, fullClassificationVector, ...
            ~, ~, dataStream] = CalculateFullFeatureMatrix(testDatabase, ...
            handles.activitiesUsed, validSubjects, validActivities, ...
            handles.testingWindowWidth, handles.testingFeatures, validFeatures);

        % Plot the data for the given channel
        handles.testData = dataStream;
        testChannel = get(handles.TestChannelPopUp, 'Value');
        PlotTestData(testChannel, handles, fullClassificationVector);

        % Display the prediction for the labeled data
        PlotPrediction(handles, fullShapeletMatrix, fullFeaturesMatrix, ...
            fullClassificationVector);

        handles.testingClassificationVector = fullClassificationVector;

    end
    
    % Update handles structure
    guidata(hObject, handles);
end

% --- #34 --- %
function [database, activities] = LoadDataFromDirectory(activities)

    % Preallocate for 100 subjects, 10 trials and 20 activities to start
    % These are just estimates but it's the best we can do here
    preallocSubj = 100;
    preallocTrials = 10;
    preallocAct = 20;
    
    % Preallocate database for speed
    database = cell(1, preallocSubj);

    % First, we need to find where all of the data is. Display a directory
    % lookup dialog to the user
    dirname = uigetdir('', 'Select Data Directory');
    
    % If the user did not specify a folder name or any other error
    % happened, 0 will be returned so check for that case and simply quit
    if (dirname == 0)
        return;
    end
    
    % Save the current working directory so that we can come back to it
    % later
    curdir = pwd;
    
    % Navigate to the path where all of the files are stored
    cd(dirname);
    
    % Read all of the files in the directory into a struct
    files = dir;
    
    % If there are activites prespecified it means that no new activities
    % should be added
    if (~isempty(activities))
        addActivities = 0;
        preallocAct = length(activities);
    else
        addActivities = 1;
    end
    
    loadDataWaitbar = waitbar(0, 'Parsing data from file ...');
    
    % Iterate through the struct and only use those files that contain data
    for index = 1:size(files,1)
        
        fileName = files(index).name;
        
        waitbar(index / size(files, 1), loadDataWaitbar, ...
            ['Parsing data from file ', fileName]);
         
        % Data files will always start with 'Sub_' and end with '.txt'
        if (length(fileName) > 8 && strcmp('Sub_', fileName(1:4)) && ...
                strcmp('.txt', fileName(length(fileName)-3:length(fileName))))
            % Parse the relevant information from the filename
            
            % Import the data
            data = importdata(fileName);
            
            % Find the subject number
            fileName = fileName(5:length(fileName)-4);
            strpos = strfind(fileName, '_');
            strpos = strpos(1);
            subjectStr = fileName(1:strpos - 1);
            subject = str2double(subjectStr);
            
            % Find the trial number
            fileName = fileName(strpos+7:length(fileName));
            strpos = strfind(fileName, '_');
            strpos = strpos(1);
            trialStr = fileName(1:strpos - 1);
            trial = str2double(trialStr);
            
            % Find the activity name
            activity = fileName(strpos+1:length(fileName));
            
            if (~addActivities)
                % Some activity names are different across datasets but
                % represent the same activity. Take care of this problem here
                if (~isempty(find(ismember(activities, 'Cycling'), 1)) && strcmp(activity, 'Bike'))
                    activity = 'Cycling';
                end
                if (~isempty(find(ismember(activities, 'Bike'), 1)) && strcmp(activity, 'Cycling'))
                    activity = 'Bike';
                end
                if (~isempty(find(ismember(activities, 'Knee_extensions'), 1)) && strcmp(activity, 'Exercise'))
                    activity = 'Knee_extensions';
                end
                if (~isempty(find(ismember(activities, 'Exercise'), 1)) && strcmp(activity, 'Knee_extensions'))
                    activity = 'Exercise';
                end
            end
            
            % Find the activity in the activities array or add it if this a
            % new activity
            activityIndex = find(ismember(activities, activity));
            if (isempty(activityIndex) && addActivities)
                activityIndex = length(activities) + 1;
                activities{activityIndex} = activity;
            end
            
            if (~isempty(activityIndex))
                % Preallocate the number of trials if needed
                if (isempty(database{subject}))
                    database{subject} = cell(1, preallocTrials);
                end

                % Preallocate the number of activities if needed
                if (isempty(database{subject}{trial}))
                    database{subject}{trial} = cell(1, preallocAct);
                end

                % Add this data to the database
                database{subject}{trial}{activityIndex} = data;
            end
        end
    end
    
    delete(loadDataWaitbar);
    
    % Return to the current working directory at the end of the function
    cd(curdir);
end

% --- #35 --- %
function [fullShapeletMatrix, fullFeaturesMatrix, fullClassificationVector, ...
    subjectsUsed, activitiesUsed, dataStream, fullOriginVector] = ...
    CalculateFullFeatureMatrix(database, activities, validSubjects, ...
    validActivities, windowWidth, featureArray, validFeatures)

    % First we want to calculate features on each of the data matrices 
    % and create a matrix of all of the observations
    featureCalcWaitbar = waitbar(0, 'Calculating features for .. ');

    fullShapeletMatrix = [];
    fullFeaturesMatrix = [];
    fullClassificationVector = {};
    fullOriginVector = {};
    subjectsUsed = cell(1, sum(validSubjects));
    subjectIndex = 1;
    dataStream = [];
    
    numVisitedCombinations = 0;
    % To make the waitbar more useful we need to figure out how many
    % subject/trial combinations we will visit
    for subject = 1:length(database)
        if (~isempty(database{subject}) && validSubjects(subject) == 1)
            for trial = 1:length(database{subject})
                if (~isempty(database{subject}{trial}))
                    numVisitedCombinations = numVisitedCombinations + 1;
                end
            end
        end
    end
    
    visitedCombinations = 0;
    for subject = 1:length(database)
        if (~isempty(database{subject}) && validSubjects(subject) == 1)
            for trial = 1:length(database{subject})
                if (~isempty(database{subject}{trial}))
                    waitbar(visitedCombinations / numVisitedCombinations, ...
                        featureCalcWaitbar, ['Calculating features for subject ', ...
                        num2str(subject), ' trial ', num2str(trial)]);
                    visitedCombinations = visitedCombinations + 1;

                    % Record that we used this subject-trial combination
                    origin = ['Subject ', num2str(subject), ', Trial ' num2str(trial)];
                    subjectsUsed{subjectIndex} = origin;
                    subjectIndex = subjectIndex + 1;
                    for activity = 1:length(database{subject}{trial})
                        
                        % Calculate features on the raw activity data
                        activityData = database{subject}{trial}{activity};
                        if (~isempty(activityData) && validActivities(activity) == 1)
                            [shapeletMatrix, featureMatrix] = CreateFeatureDataMatrix(activityData, ...
                                windowWidth, featureArray, validFeatures, 0);
                            
                            newRows = size(shapeletMatrix, 1);
                            classificationVector = cell(1, newRows);
                            originVector = cell(1, newRows);
                            for index = 1:newRows
                                classificationVector(index) = activities(activity);
                                originVector(index) = cellstr(origin);
                            end
                            
                            % Add each feature matrix and classificaion
                            % vector to the full feature matrix and full
                            % classification vector
                            currentRows = size(fullShapeletMatrix, 1);
                            fullShapeletMatrix(currentRows + 1:currentRows + newRows,:) = ...
                                shapeletMatrix;
                            fullFeaturesMatrix(currentRows + 1:currentRows + newRows,:) = ...
                                featureMatrix;
                            fullClassificationVector(currentRows + 1:currentRows + newRows) = ...
                                classificationVector;
                            fullOriginVector(currentRows + 1:currentRows + newRows) = ...
                                originVector;
                            
                            % Add the raw activity data to the data stream
                            currentDataRow = size(dataStream, 1);
                            sampleSize = getappdata(0, 'samplingRate') * windowWidth;
                            newRows = floor(size(activityData, 1) / sampleSize) * sampleSize;
                            dataStream(currentDataRow + 1:currentDataRow + newRows,:) = ...
                                activityData(1:newRows,:);                            
                        end
                    end
                end
            end
        end
    end

    delete(featureCalcWaitbar);
    
    % Finally, generate the used activities list
    activitiesUsed = cell(1, sum(validActivities));
    activityIndex = 1;
    for activity = 1:length(activities)
        if (validActivities(activity) == 1)
            activitiesUsed{activityIndex} = activities{activity};
            activityIndex = activityIndex + 1;
        end
    end

end

% --- #36 --- %
function [validSubjects, validActivities, validFeatures, SAXWindowWidth, ...
    SAXCardinality, numCandidatesPerClass, minShapelet, maxShapelet] = ...
    GetSubjectsActivitiesFromUser(database, activities, featureArray, testingMode)

    validSubjects = [];
    validActivities = [];
    validFeatures = [];

    % Set up selectableSubjects
    selectableSubjects = zeros(1, sum(~cellfun(@isempty, database)));
    subjectIndex = 1;
    for subject = 1:length(database)
        if (~isempty(database{subject}))
            selectableSubjects(subjectIndex) = subject;
            subjectIndex = subjectIndex + 1;
        end
    end
    setappdata(0, 'selectableSubjects', selectableSubjects);
    
    % Use the activities cell array as selectableActivities
    setappdata(0, 'selectableActivities', activities);
    
    setappdata(0, 'selectableFeatures', featureArray);
    
    setappdata(0, 'testingMode', testingMode);

    % Launch the ClassifyGUI to choose the subjects and activities to use
    newConfig = ClassifyGUI;

    % Wait for the GUI to close
    waitfor(newConfig);
    
    selectedActivities = getappdata(0, 'selectedActivities');
        
    % Make sure we selected some activities
    if (~isempty(selectedActivities))
        validActivities = zeros(1, length(activities));
        for index = 1:length(selectedActivities)
            validActivities(selectedActivities(index)) = 1;
        end
    else
        return;
    end
    
    % If the user selected automated training then we can simply quit here
    if (getappdata(0, 'automatedTraining') == 1)
        % Add fake values just to pass the check in Classify
        validSubjects = ones(1, length(database));
        validFeatures = ones(1, length(featureArray));
        return;
    end
    
    selectedSubjects = getappdata(0, 'selectedSubjects');
    selectedFeatures = getappdata(0, 'selectedFeatures');
    SAXWindowWidth = getappdata(0, 'SAXWindowWidth');
    SAXCardinality = getappdata(0, 'SAXCardinality');
    numCandidatesPerClass = getappdata(0, 'numCandidatesClass');
    minShapelet = getappdata(0, 'minShapelet');
    maxShapelet = getappdata(0, 'maxShapelet');
    
    % Only continue if the user selected at least one subject and activity
    if (~(isempty(selectedSubjects) || isempty(selectedFeatures)))
    
        % Record all of the valid subjects and activities
        validSubjects = zeros(1, length(database));
        for index = 1:length(selectedSubjects)
            validSubjects(selectableSubjects(selectedSubjects(index))) = 1;
        end
        
        validFeatures = zeros(1, length(featureArray));
        for index = 1:length(selectedFeatures)
            validFeatures(selectedFeatures(index)) = 1;
        end
    end
end

% --- #37 --- %
function PlotPrediction(handles, shapeletMatrix, featureMatrix, classificationVector)
    % Use the predict function of the classification tree
    thresholdValue = getappdata(0, 'classThresholdValue');
    numChannels = length(getappdata(0, 'channelNames'));
    
    [SAXMatrix, ~, distMat] = TransformToSAX(shapeletMatrix, ...
            numChannels, handles.SAXWindowWidth, handles.SAXCardinality);
    
    [predictedActivities, ~, classificationError, unknownPercent] = ...
        classifyDataShapelet(handles.tree, featureMatrix, SAXMatrix, ...
        handles.activitiesUsed, numChannels, 0, thresholdValue, ...
        classificationVector, distMat);
    
    predictedActivityNumbers = zeros(1, length(predictedActivities));
    activityCount = zeros(1, length(handles.activitiesUsed) + 1);

    % Now we need to convert the activity names to numbers to be able to
    % graph them. Also record how many times each activity was done for the
    % pie chart
    for activity = 1:length(predictedActivities)
        if (strcmp(predictedActivities{activity}, 'Unknown'))
            activityIndex = length(handles.activitiesUsed) + 1;
        else
            activityIndex = find(ismember(handles.activitiesUsed, ...
                predictedActivities{activity}));
        end
        predictedActivityNumbers(activity) = activityIndex;
        activityCount(activityIndex) = activityCount(activityIndex) + 1;
    end

    namesWithPercentages = cell(1, length(handles.activitiesUsed) + 1);
    for activity = 1:length(handles.activitiesUsed)
        namesWithPercentages{activity} = [handles.activitiesUsed{activity}, ...
            ': ', num2str(activityCount(activity)/length(predictedActivities) * 100), '%'];
    end
    % Add the unknown category
    namesWithPercentages{length(handles.activitiesUsed) + 1} = ['Unknown: ',...
        num2str(activityCount(length(handles.activitiesUsed) + 1)/length(predictedActivities) * 100), '%'];

    % Display a pie chart of the activities
    figure('Name', 'Classification Pie Chart', 'NumberTitle', 'off');
    pie2(activityCount, namesWithPercentages);

    % Graph the predicted activity
    timeVector = MakeTimeVector(length(predictedActivityNumbers), ...
        handles.testingWindowWidth);

    % We need to split the data up according to the activity and make a
    % separate plot for each
    coloringWaitbar = waitbar(0, 'Coloring data');
    axes(handles.PredictionAxes);

    plotData = zeros(length(timeVector), length(handles.activitiesUsed));
    for activity = 1:(length(handles.activitiesUsed) + 1)
        for timestep = 1:length(timeVector)
            if (activity == predictedActivityNumbers(timestep))
                plotData(timestep, activity) = activity;
            else
                plotData(timestep, activity) = NaN;
            end
        end
        waitbar(activity / length(handles.activitiesUsed), coloringWaitbar);
    end

    delete(coloringWaitbar);

    plot(timeVector, plotData, '+');

    % Create a legend to properly label the plotted data
    legendActivities = handles.activitiesUsed;
    legendActivities{length(handles.activitiesUsed) + 1} = 'Unknown';
    legend(legendActivities);

    xlabel('Time (seconds)');
    ylabel('Activity number');

    % Print the perfect correct in the title if we were given a
    % classification vector
    if (isempty(classificationVector))
        title('Prediction');
    else
        title(['Prediction - ', num2str((1 - classificationError) * 100), ...
            '% correct']);
    end

    disp(['Unknown threshold = ', num2str(thresholdValue * 100), '% Classification Percentage ',...
        num2str((1 - classificationError) * 100), '% correct']);
    disp([num2str(unknownPercent * 100), '% of predictions unknown']);
end

% --- #38 --- %
function AnalyzeFeaturesButton_Callback(~, ~, handles) %#ok<DEFNU>
    % hObject    handle to AnalyzeFeaturesButton (see GCBO)
    % eventdata  reserved - to be defined in a future version of MATLAB
    % handles    structure with handles and user data (see GUIDATA)
    
    % Do nothing if we haven't populated the data yet
    if (isempty(handles.database))
        errordlg('Must first load data!', 'Analyze Features Error');
        return;
    end
    
    % Calculate features and save that for the AnalyzeFeaturesGUI
    validSubjects = ones(1, length(handles.database));
    validActivities = ones(1, length(handles.activities));
    validFeatures = ones(1, length(handles.featureArray));
    
    [~, fullFeatureMatrix, fullClassificationVector, ...
    ~, activitiesUsed, ~, fullOriginVector] = ...
        CalculateFullFeatureMatrix(handles.database, handles.activities, ...
        validSubjects, validActivities, handles.trainingWindowWidth, ...
        handles.featureArray, validFeatures);
    
    setappdata(0, 'analyzeFeatureMatrix', fullFeatureMatrix);
    setappdata(0, 'analyzeClassificationVector', fullClassificationVector);
    setappdata(0, 'analyzeActivitiesUsed', activitiesUsed);
    setappdata(0, 'analyzeFeatureArray', handles.featureArray);
    setappdata(0, 'analyzeChannelNames', getappdata(0, 'channelNames'));
    setappdata(0, 'analyzeOriginVector', fullOriginVector);
    
    % Create a new AnalyzeFeaturesGUI
    analyzeFeatures = AnalyzeFeaturesGUI;
    
    % Wait for the GUI to close
    waitfor(analyzeFeatures);
end

% --- #39 --- %
function [prunedShapeletMatrix, prunedFeaturesMatrix, prunedClassificationVector] ...
    = RemoveOutliers(fullShapeletMatrix, fullFeaturesMatrix, ...
    fullClassificationVector, activitiesUsed)

    % Eliminate any training data windows that are clearly non-representative of their activity. 

    % Allocate the maximum amount of memory for the pruned feature matrices
    % and we will shrink them to size later
    prunedShapeletMatrix = zeros(size(fullShapeletMatrix, 1), size(fullShapeletMatrix, 2));
    prunedFeaturesMatrix = zeros(size(fullFeaturesMatrix, 1), size(fullFeaturesMatrix, 2));
    prunedClassificationVector = cell(1, length(fullClassificationVector));
    numFinalInstances = 0;

    for selectedActivityIndex = 1:length(activitiesUsed)
        % Find all of the feature values for this activity
        selectedIndices = ismember(fullClassificationVector, activitiesUsed{selectedActivityIndex});
        
        % Filter all of the found activity feature values
        featureColumns = size(fullFeaturesMatrix, 2);
        numInstances = sum(selectedIndices);
        activityFeatures = fullFeaturesMatrix(selectedIndices, :);
        activityShapelet = fullShapeletMatrix(selectedIndices, :);
        
        % Keep track of the instances outside of the 3 sd range
        outlierCounts = zeros(1, numInstances);
        
        % Calculate the outliers
        for feature = 1:featureColumns
            dataMean = mean(activityFeatures(:, feature));
            dataSd = std(activityFeatures(:, feature));

            dataMin = dataMean - 3 * dataSd;
            dataMax = dataMean + 3 * dataSd;

            % Record all of the outliers
            for instance = 1:numInstances
                if (activityFeatures(instance, feature) < dataMin || ...
                        activityFeatures(instance, feature) > dataMax)
                    outlierCounts(instance) = outlierCounts(instance) + 1;
                end
            end
        end
        
        % Print out how many instances will be removed with the given
        % outlier threshold
        outlierThreshold = 1;
        prunedInstances = outlierCounts > outlierThreshold;
        numPruned = sum(prunedInstances);
        numNotPruned = length(prunedInstances) - numPruned;
        disp([num2str(numPruned), ' instances pruned for ', ...
            activitiesUsed{selectedActivityIndex}, ' (', ...
            num2str(numPruned / numInstances * 100), '% of activities)']);
        
        % Take only the non-pruned instances
        prunedFeaturesMatrix(numFinalInstances + 1:numFinalInstances + numNotPruned, :) = ...
            activityFeatures(~prunedInstances, :);
        prunedShapeletMatrix(numFinalInstances + 1:numFinalInstances + numNotPruned, :) = ...
            activityShapelet(~prunedInstances, :);
        prunedClassificationVector(numFinalInstances + 1:numFinalInstances + numNotPruned) = ...
            activitiesUsed(selectedActivityIndex);
        numFinalInstances = numFinalInstances + numNotPruned;
    end
    
    % Remove all of the zero values at the end
    prunedFeaturesMatrix = prunedFeaturesMatrix(1:numFinalInstances, :);
    prunedShapeletMatrix = prunedShapeletMatrix(1:numFinalInstances, :);
    prunedClassificationVector = prunedClassificationVector(1:numFinalInstances);
end
